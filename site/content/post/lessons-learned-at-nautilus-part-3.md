---
title: Lessons Learned at Nautilus (Part 3)
date: '2021-10-02T09:22:43-07:00'
---
<img style="float: left; margin:0 2em 1em 0; width: 33%" src="/img/blog/droid.png"/> In my two and a half years at Nautilus I learned a tremendous amount about IoT, Hardware, Software, Data Science, and myself in general.  This will be the last entry in Nautilus lessons learned series and will cover how hardware can unintentionally impact software and the benefits of Android OS for IoT.

One of the best parts of my time at Nautilus was all the firmware and electrical engineers that I got to interact with and learn from.  My undergraduate degree was in computer science.  The syllabus had exactly two electrical engineering courses, "Digital Computer Logic" and "Introduction to Computer Architecture". I got a little bit into electromagnetic theory and Maxwell's equations in my Advanced Physics course, but ultimately only scratched the surface of all the content available in electrical engineering.   My computer science education covered a lot of the theory of computer operation and programming.  Data structures, algorithms, operating systems, computer graphics, etc.  While at Nautilus I had the privilege of revisiting many of the electrical concepts that I only briefly touched on while in school.

Nautilus, as a fitness equipment company, is enmeshed in firmware and hardware development as a necessity.  These systems would impact the operation of our software systems more than you would expect.  The most noteworthy instance was an issue with heartrate logging on our BXT116 treadmills when connected to the JRNY app.  When I was assigned the bug both our iOS and Android apps were reporting long stretches of a flat heart rate.  That is, it would report 160 beats per minute for 5 minutes, then 170 for 4 minutes, then 156 for 8 minutes, and so on.  Digging into the iOS code I found that we had set the threshold for our Douglas-Peucker algorithm too high.  The algorithm is a type of interpolation program that smooths out rapid jumps in a graphed line.  Because the threshold was too high, it flattened the graphed beats per minute into a line that would only change after a fairly significant change in heart rate.  A fairly straightforward software issue.

Android was quite different.  I found our interpolation was just fine on that platform.  Digging into it deeper I found that the our BLE byte decoding logic was giving us those values.  Since our electrical engineers built and maintained the firmware that generated those byte values on the console, I asked them why we were getting these bytes and why the iOS logic handled them differently.  It turned out that the way the heart rate sensor hardware was constructed was to blame.  Specifically, the heart rate band that shipped with the BXT116 operated in the 5khz range.  This range is not regulated by the FCC, and is thus subject to electrical interference.  In our case the treadmill motor, when the under load of propelling an individual while they are running (which I personally did for the purposes of reproducing the bug as exactly as possible), generates an electromagnetic field in the 5khz range.  On iOS the byte decoding logic would recognize this as noise and remove it from the heart rate date.  But on Android the byte decoding logic would coerce the noise into the nearest reasonable heart rate reading.  Once this was determined we updated the Android logic to match that on iOS and the bug was fixed.

 Android OS for IoT
